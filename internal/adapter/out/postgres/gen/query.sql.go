// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package gen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addExerciseToTraining = `-- name: AddExerciseToTraining :one
INSERT INTO trained_exercise (
    training_id,
    exercise_id,
    weight,
    approaches,
    reps,
    time,
    doing,
    rest,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, training_id, exercise_id, weight, approaches, reps, time, doing, rest, notes
`

type AddExerciseToTrainingParams struct {
	TrainingID int64          `json:"training_id"`
	ExerciseID int64          `json:"exercise_id"`
	Weight     sql.NullString `json:"weight"`
	Approaches sql.NullInt32  `json:"approaches"`
	Reps       sql.NullInt32  `json:"reps"`
	Time       sql.NullInt64  `json:"time"`
	Doing      sql.NullInt64  `json:"doing"`
	Rest       sql.NullInt64  `json:"rest"`
	Notes      sql.NullString `json:"notes"`
}

func (q *Queries) AddExerciseToTraining(ctx context.Context, arg AddExerciseToTrainingParams) (TrainedExercise, error) {
	row := q.db.QueryRowContext(ctx, addExerciseToTraining,
		arg.TrainingID,
		arg.ExerciseID,
		arg.Weight,
		arg.Approaches,
		arg.Reps,
		arg.Time,
		arg.Doing,
		arg.Rest,
		arg.Notes,
	)
	var i TrainedExercise
	err := row.Scan(
		&i.ID,
		&i.TrainingID,
		&i.ExerciseID,
		&i.Weight,
		&i.Approaches,
		&i.Reps,
		&i.Time,
		&i.Doing,
		&i.Rest,
		&i.Notes,
	)
	return i, err
}

const calculateTrainingTotalTime = `-- name: CalculateTrainingTotalTime :one
SELECT 
    COALESCE(SUM(EXTRACT(EPOCH FROM te.doing)), 0) as total_exercise_seconds,
    COALESCE(SUM(EXTRACT(EPOCH FROM te.rest)), 0) as total_rest_seconds,
    COALESCE(SUM(EXTRACT(EPOCH FROM te.doing)) + SUM(EXTRACT(EPOCH FROM te.rest)), 0) as total_seconds
FROM trained_exercise te
WHERE te.training_id = $1
`

type CalculateTrainingTotalTimeRow struct {
	TotalExerciseSeconds interface{} `json:"total_exercise_seconds"`
	TotalRestSeconds     interface{} `json:"total_rest_seconds"`
	TotalSeconds         interface{} `json:"total_seconds"`
}

// Расчет общего времени тренировки на основе всех упражнений
func (q *Queries) CalculateTrainingTotalTime(ctx context.Context, trainingID int64) (CalculateTrainingTotalTimeRow, error) {
	row := q.db.QueryRowContext(ctx, calculateTrainingTotalTime, trainingID)
	var i CalculateTrainingTotalTimeRow
	err := row.Scan(&i.TotalExerciseSeconds, &i.TotalRestSeconds, &i.TotalSeconds)
	return i, err
}

const createTraining = `-- name: CreateTraining :one
INSERT INTO training (
    user_id,
    is_done,
    planned_date,
    actual_date,
    started_at,
    finished_at,
    total_duration,
    total_rest_time,
    total_exercise_time,
    rating
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, user_id, is_done, planned_date, actual_date, started_at, finished_at, total_duration, total_rest_time, total_exercise_time, rating
`

type CreateTrainingParams struct {
	UserID            uuid.UUID     `json:"user_id"`
	IsDone            bool          `json:"is_done"`
	PlannedDate       time.Time     `json:"planned_date"`
	ActualDate        sql.NullTime  `json:"actual_date"`
	StartedAt         sql.NullTime  `json:"started_at"`
	FinishedAt        sql.NullTime  `json:"finished_at"`
	TotalDuration     sql.NullInt64 `json:"total_duration"`
	TotalRestTime     sql.NullInt64 `json:"total_rest_time"`
	TotalExerciseTime sql.NullInt64 `json:"total_exercise_time"`
	Rating            sql.NullInt32 `json:"rating"`
}

func (q *Queries) CreateTraining(ctx context.Context, arg CreateTrainingParams) (Training, error) {
	row := q.db.QueryRowContext(ctx, createTraining,
		arg.UserID,
		arg.IsDone,
		arg.PlannedDate,
		arg.ActualDate,
		arg.StartedAt,
		arg.FinishedAt,
		arg.TotalDuration,
		arg.TotalRestTime,
		arg.TotalExerciseTime,
		arg.Rating,
	)
	var i Training
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IsDone,
		&i.PlannedDate,
		&i.ActualDate,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TotalDuration,
		&i.TotalRestTime,
		&i.TotalExerciseTime,
		&i.Rating,
	)
	return i, err
}

const deleteExerciseFromTraining = `-- name: DeleteExerciseFromTraining :exec
DELETE FROM trained_exercise 
WHERE id = $1 AND training_id = $2
`

type DeleteExerciseFromTrainingParams struct {
	ID         int64 `json:"id"`
	TrainingID int64 `json:"training_id"`
}

func (q *Queries) DeleteExerciseFromTraining(ctx context.Context, arg DeleteExerciseFromTrainingParams) error {
	_, err := q.db.ExecContext(ctx, deleteExerciseFromTraining, arg.ID, arg.TrainingID)
	return err
}

const deleteTrainingAndExercises = `-- name: DeleteTrainingAndExercises :exec
WITH deleted_exercises AS (
    DELETE FROM trained_exercise WHERE training_id = $1
)
DELETE FROM training WHERE training.id = $1
`

func (q *Queries) DeleteTrainingAndExercises(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTrainingAndExercises, id)
	return err
}

const getAllTags = `-- name: GetAllTags :many
SELECT id, type FROM tag ORDER BY id
`

func (q *Queries) GetAllTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Type); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentTraining = `-- name: GetCurrentTraining :one
SELECT 
    t.id, t.user_id, t.is_done, t.planned_date, t.actual_date, t.started_at, t.finished_at, t.total_duration, t.total_rest_time, t.total_exercise_time, t.rating,
    COALESCE(
        json_agg(
            json_build_object(
                'id', te.id,
                'exercise_id', te.exercise_id,
                'weight', te.weight,
                'approaches', te.approaches,
                'reps', te.reps,
                'time', te.time,
                'doing', te.doing,
                'rest', te.rest,
                'notes', te.notes
            )
        ) FILTER (WHERE te.id IS NOT NULL),
        '[]'
    ) as exercises
FROM training t
LEFT JOIN trained_exercise te ON t.id = te.training_id
WHERE t.user_id = $1 
    AND t.planned_date = CURRENT_DATE
    AND t.is_done = false
GROUP BY t.id
ORDER BY t.planned_date DESC
LIMIT 1
`

type GetCurrentTrainingRow struct {
	ID                int64         `json:"id"`
	UserID            uuid.UUID     `json:"user_id"`
	IsDone            bool          `json:"is_done"`
	PlannedDate       time.Time     `json:"planned_date"`
	ActualDate        sql.NullTime  `json:"actual_date"`
	StartedAt         sql.NullTime  `json:"started_at"`
	FinishedAt        sql.NullTime  `json:"finished_at"`
	TotalDuration     sql.NullInt64 `json:"total_duration"`
	TotalRestTime     sql.NullInt64 `json:"total_rest_time"`
	TotalExerciseTime sql.NullInt64 `json:"total_exercise_time"`
	Rating            sql.NullInt32 `json:"rating"`
	Exercises         interface{}   `json:"exercises"`
}

// Получение тренировки на сегодня для пользователя
func (q *Queries) GetCurrentTraining(ctx context.Context, userID uuid.UUID) (GetCurrentTrainingRow, error) {
	row := q.db.QueryRowContext(ctx, getCurrentTraining, userID)
	var i GetCurrentTrainingRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IsDone,
		&i.PlannedDate,
		&i.ActualDate,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TotalDuration,
		&i.TotalRestTime,
		&i.TotalExerciseTime,
		&i.Rating,
		&i.Exercises,
	)
	return i, err
}

const getExerciseByID = `-- name: GetExerciseByID :one
SELECT 
    e.id,
    e.description,
    e.href,
    COALESCE(
        json_agg(
            json_build_object(
                'id', t.id,
                'type', t.type
            )
        ) FILTER (WHERE t.id IS NOT NULL),
        '[]'
    ) as tags
FROM exercise e
LEFT JOIN exercise_to_tag et ON e.id = et.exercise_id
LEFT JOIN tag t ON et.tag_id = t.id
WHERE e.id = $1
GROUP BY e.id, e.description, e.href
`

type GetExerciseByIDRow struct {
	ID          int64       `json:"id"`
	Description string      `json:"description"`
	Href        string      `json:"href"`
	Tags        interface{} `json:"tags"`
}

func (q *Queries) GetExerciseByID(ctx context.Context, id int64) (GetExerciseByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getExerciseByID, id)
	var i GetExerciseByIDRow
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Href,
		&i.Tags,
	)
	return i, err
}

const getExercisesByTag = `-- name: GetExercisesByTag :many
SELECT 
    e.id,
    e.description,
    e.href
FROM exercise e
INNER JOIN exercise_to_tag et ON e.id = et.exercise_id
WHERE et.tag_id = $1
ORDER BY e.id
`

func (q *Queries) GetExercisesByTag(ctx context.Context, tagID int64) ([]Exercise, error) {
	rows, err := q.db.QueryContext(ctx, getExercisesByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(&i.ID, &i.Description, &i.Href); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExercisesWithTags = `-- name: GetExercisesWithTags :many
SELECT 
    e.id,
    e.description,
    e.href,
    COALESCE(
        json_agg(
            json_build_object(
                'id', t.id,
                'type', t.type
            )
        ) FILTER (WHERE t.id IS NOT NULL),
        '[]'
    ) as tags
FROM exercise e
LEFT JOIN exercise_to_tag et ON e.id = et.exercise_id
LEFT JOIN tag t ON et.tag_id = t.id
GROUP BY e.id, e.description, e.href
ORDER BY e.id
`

type GetExercisesWithTagsRow struct {
	ID          int64       `json:"id"`
	Description string      `json:"description"`
	Href        string      `json:"href"`
	Tags        interface{} `json:"tags"`
}

func (q *Queries) GetExercisesWithTags(ctx context.Context) ([]GetExercisesWithTagsRow, error) {
	rows, err := q.db.QueryContext(ctx, getExercisesWithTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExercisesWithTagsRow{}
	for rows.Next() {
		var i GetExercisesWithTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Href,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalTrainingByLevel = `-- name: GetGlobalTrainingByLevel :one
SELECT 
    gt.id,
    gt.level,
    COALESCE(
        json_agg(
            json_build_object(
                'id', e.id,
                'description', e.description,
                'href', e.href
            )
        ) FILTER (WHERE e.id IS NOT NULL),
        '[]'
    ) as exercises
FROM global_training gt
LEFT JOIN global_training_exercise gte ON gt.id = gte.global_training_id
LEFT JOIN exercise e ON gte.exercise_id = e.id
WHERE gt.level = $1
GROUP BY gt.id, gt.level
`

type GetGlobalTrainingByLevelRow struct {
	ID        int64       `json:"id"`
	Level     string      `json:"level"`
	Exercises interface{} `json:"exercises"`
}

// Получение глобальной тренировки по уровню
func (q *Queries) GetGlobalTrainingByLevel(ctx context.Context, level string) (GetGlobalTrainingByLevelRow, error) {
	row := q.db.QueryRowContext(ctx, getGlobalTrainingByLevel, level)
	var i GetGlobalTrainingByLevelRow
	err := row.Scan(&i.ID, &i.Level, &i.Exercises)
	return i, err
}

const getGlobalTrainingWithTags = `-- name: GetGlobalTrainingWithTags :one
SELECT 
    gt.id,
    gt.level,
    COALESCE(
        json_agg(
            DISTINCT json_build_object(
                'id', e.id,
                'description', e.description,
                'href', e.href,
                'tags', COALESCE(
                    (
                        SELECT json_agg(
                            json_build_object(
                                'id', t2.id,
                                'type', t2.type
                            )
                        )
                        FROM exercise_to_tag et2
                        JOIN tag t2 ON et2.tag_id = t2.id
                        WHERE et2.exercise_id = e.id
                    ),
                    '[]'
                )
            )
        ) FILTER (WHERE e.id IS NOT NULL),
        '[]'
    ) as exercises
FROM global_training gt
LEFT JOIN global_training_exercise gte ON gt.id = gte.global_training_id
LEFT JOIN exercise e ON gte.exercise_id = e.id
WHERE gt.level = $1
GROUP BY gt.id, gt.level
`

type GetGlobalTrainingWithTagsRow struct {
	ID        int64       `json:"id"`
	Level     string      `json:"level"`
	Exercises interface{} `json:"exercises"`
}

// Получение глобальной тренировки с тегами упражнений
func (q *Queries) GetGlobalTrainingWithTags(ctx context.Context, level string) (GetGlobalTrainingWithTagsRow, error) {
	row := q.db.QueryRowContext(ctx, getGlobalTrainingWithTags, level)
	var i GetGlobalTrainingWithTagsRow
	err := row.Scan(&i.ID, &i.Level, &i.Exercises)
	return i, err
}

const getGlobalTrainings = `-- name: GetGlobalTrainings :many
SELECT 
    gt.id,
    gt.level,
    COALESCE(
        json_agg(
            json_build_object(
                'id', e.id,
                'description', e.description,
                'href', e.href
            )
        ) FILTER (WHERE e.id IS NOT NULL),
        '[]'
    ) as exercises
FROM global_training gt
LEFT JOIN global_training_exercise gte ON gt.id = gte.global_training_id
LEFT JOIN exercise e ON gte.exercise_id = e.id
GROUP BY gt.id, gt.level
ORDER BY 
    CASE gt.level 
        WHEN 'beginner' THEN 1
        WHEN 'intermediate' THEN 2
        WHEN 'advanced' THEN 3
    END
`

type GetGlobalTrainingsRow struct {
	ID        int64       `json:"id"`
	Level     string      `json:"level"`
	Exercises interface{} `json:"exercises"`
}

// Получение всех глобальных тренировок
func (q *Queries) GetGlobalTrainings(ctx context.Context) ([]GetGlobalTrainingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getGlobalTrainings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGlobalTrainingsRow{}
	for rows.Next() {
		var i GetGlobalTrainingsRow
		if err := rows.Scan(&i.ID, &i.Level, &i.Exercises); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodaysTraining = `-- name: GetTodaysTraining :many
SELECT 
    t.id, t.user_id, t.is_done, t.planned_date, t.actual_date, t.started_at, t.finished_at, t.total_duration, t.total_rest_time, t.total_exercise_time, t.rating,
    COALESCE(
        json_agg(
            json_build_object(
                'id', te.id,
                'exercise_id', te.exercise_id,
                'weight', te.weight,
                'approaches', te.approaches,
                'reps', te.reps,
                'time', te.time,
                'doing', te.doing,
                'rest', te.rest,
                'notes', te.notes
            )
        ) FILTER (WHERE te.id IS NOT NULL),
        '[]'
    ) as exercises
FROM training t
LEFT JOIN trained_exercise te ON t.id = te.training_id
WHERE t.user_id = $1 
    AND t.planned_date = CURRENT_DATE
GROUP BY t.id
ORDER BY t.planned_date DESC
`

type GetTodaysTrainingRow struct {
	ID                int64         `json:"id"`
	UserID            uuid.UUID     `json:"user_id"`
	IsDone            bool          `json:"is_done"`
	PlannedDate       time.Time     `json:"planned_date"`
	ActualDate        sql.NullTime  `json:"actual_date"`
	StartedAt         sql.NullTime  `json:"started_at"`
	FinishedAt        sql.NullTime  `json:"finished_at"`
	TotalDuration     sql.NullInt64 `json:"total_duration"`
	TotalRestTime     sql.NullInt64 `json:"total_rest_time"`
	TotalExerciseTime sql.NullInt64 `json:"total_exercise_time"`
	Rating            sql.NullInt32 `json:"rating"`
	Exercises         interface{}   `json:"exercises"`
}

// Получение всех тренировок на сегодня для пользователя
func (q *Queries) GetTodaysTraining(ctx context.Context, userID uuid.UUID) ([]GetTodaysTrainingRow, error) {
	rows, err := q.db.QueryContext(ctx, getTodaysTraining, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTodaysTrainingRow{}
	for rows.Next() {
		var i GetTodaysTrainingRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.IsDone,
			&i.PlannedDate,
			&i.ActualDate,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TotalDuration,
			&i.TotalRestTime,
			&i.TotalExerciseTime,
			&i.Rating,
			&i.Exercises,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrainingStats = `-- name: GetTrainingStats :one
SELECT 
    t.id,
    t.total_duration,
    t.total_rest_time,
    t.total_exercise_time,
    COUNT(te.id) as exercise_count,
    COALESCE(SUM(te.approaches), 0) as total_approaches,
    COALESCE(SUM(te.reps), 0) as total_reps
FROM training t
LEFT JOIN trained_exercise te ON t.id = te.training_id
WHERE t.id = $1
GROUP BY t.id
`

type GetTrainingStatsRow struct {
	ID                int64         `json:"id"`
	TotalDuration     sql.NullInt64 `json:"total_duration"`
	TotalRestTime     sql.NullInt64 `json:"total_rest_time"`
	TotalExerciseTime sql.NullInt64 `json:"total_exercise_time"`
	ExerciseCount     int64         `json:"exercise_count"`
	TotalApproaches   interface{}   `json:"total_approaches"`
	TotalReps         interface{}   `json:"total_reps"`
}

// Получение статистики по тренировке (общее время выполнения и отдыха)
func (q *Queries) GetTrainingStats(ctx context.Context, id int64) (GetTrainingStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getTrainingStats, id)
	var i GetTrainingStatsRow
	err := row.Scan(
		&i.ID,
		&i.TotalDuration,
		&i.TotalRestTime,
		&i.TotalExerciseTime,
		&i.ExerciseCount,
		&i.TotalApproaches,
		&i.TotalReps,
	)
	return i, err
}

const getTrainingWithExercises = `-- name: GetTrainingWithExercises :one
SELECT 
    t.id, t.user_id, t.is_done, t.planned_date, t.actual_date, t.started_at, t.finished_at, t.total_duration, t.total_rest_time, t.total_exercise_time, t.rating,
    COALESCE(
        json_agg(
            json_build_object(
                'id', te.id,
                'exercise_id', te.exercise_id,
                'weight', te.weight,
                'approaches', te.approaches,
                'reps', te.reps,
                'time', te.time,
                'doing', te.doing,
                'rest', te.rest,
                'notes', te.notes
            )
        ) FILTER (WHERE te.id IS NOT NULL),
        '[]'
    ) as exercises
FROM training t
LEFT JOIN trained_exercise te ON t.id = te.training_id
WHERE t.id = $1
GROUP BY t.id
`

type GetTrainingWithExercisesRow struct {
	ID                int64         `json:"id"`
	UserID            uuid.UUID     `json:"user_id"`
	IsDone            bool          `json:"is_done"`
	PlannedDate       time.Time     `json:"planned_date"`
	ActualDate        sql.NullTime  `json:"actual_date"`
	StartedAt         sql.NullTime  `json:"started_at"`
	FinishedAt        sql.NullTime  `json:"finished_at"`
	TotalDuration     sql.NullInt64 `json:"total_duration"`
	TotalRestTime     sql.NullInt64 `json:"total_rest_time"`
	TotalExerciseTime sql.NullInt64 `json:"total_exercise_time"`
	Rating            sql.NullInt32 `json:"rating"`
	Exercises         interface{}   `json:"exercises"`
}

func (q *Queries) GetTrainingWithExercises(ctx context.Context, id int64) (GetTrainingWithExercisesRow, error) {
	row := q.db.QueryRowContext(ctx, getTrainingWithExercises, id)
	var i GetTrainingWithExercisesRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IsDone,
		&i.PlannedDate,
		&i.ActualDate,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TotalDuration,
		&i.TotalRestTime,
		&i.TotalExerciseTime,
		&i.Rating,
		&i.Exercises,
	)
	return i, err
}

const getTrainingsByUser = `-- name: GetTrainingsByUser :many
SELECT 
    t.id,
    t.user_id,
    t.is_done,
    t.planned_date,
    t.actual_date,
    t.started_at,
    t.finished_at,
    t.total_duration,
    t.total_rest_time,
    t.total_exercise_time,
    t.rating,
    COALESCE(
        json_agg(
            json_build_object(
                'id', te.id,
                'exercise_id', te.exercise_id,
                'weight', te.weight,
                'approaches', te.approaches,
                'reps', te.reps,
                'time', te.time,
                'doing', te.doing,
                'rest', te.rest,
                'notes', te.notes
            )
        ) FILTER (WHERE te.id IS NOT NULL),
        '[]'
    ) as exercises
FROM training t
LEFT JOIN trained_exercise te ON t.id = te.training_id
WHERE t.user_id = $1
GROUP BY t.id
ORDER BY t.planned_date DESC
`

type GetTrainingsByUserRow struct {
	ID                int64         `json:"id"`
	UserID            uuid.UUID     `json:"user_id"`
	IsDone            bool          `json:"is_done"`
	PlannedDate       time.Time     `json:"planned_date"`
	ActualDate        sql.NullTime  `json:"actual_date"`
	StartedAt         sql.NullTime  `json:"started_at"`
	FinishedAt        sql.NullTime  `json:"finished_at"`
	TotalDuration     sql.NullInt64 `json:"total_duration"`
	TotalRestTime     sql.NullInt64 `json:"total_rest_time"`
	TotalExerciseTime sql.NullInt64 `json:"total_exercise_time"`
	Rating            sql.NullInt32 `json:"rating"`
	Exercises         interface{}   `json:"exercises"`
}

func (q *Queries) GetTrainingsByUser(ctx context.Context, userID uuid.UUID) ([]GetTrainingsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrainingsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTrainingsByUserRow{}
	for rows.Next() {
		var i GetTrainingsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.IsDone,
			&i.PlannedDate,
			&i.ActualDate,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TotalDuration,
			&i.TotalRestTime,
			&i.TotalExerciseTime,
			&i.Rating,
			&i.Exercises,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markTrainingAsDone = `-- name: MarkTrainingAsDone :one
UPDATE training
SET 
    is_done = true,
    actual_date = CURRENT_DATE,
    finished_at = COALESCE($1, CURRENT_TIMESTAMP)
WHERE id = $2 AND user_id = $3
RETURNING id, user_id, is_done, planned_date, actual_date, started_at, finished_at, total_duration, total_rest_time, total_exercise_time, rating
`

type MarkTrainingAsDoneParams struct {
	FinishedAt sql.NullTime `json:"finished_at"`
	ID         int64        `json:"id"`
	UserID     uuid.UUID    `json:"user_id"`
}

// Отметить тренировку как выполненную
func (q *Queries) MarkTrainingAsDone(ctx context.Context, arg MarkTrainingAsDoneParams) (Training, error) {
	row := q.db.QueryRowContext(ctx, markTrainingAsDone, arg.FinishedAt, arg.ID, arg.UserID)
	var i Training
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IsDone,
		&i.PlannedDate,
		&i.ActualDate,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TotalDuration,
		&i.TotalRestTime,
		&i.TotalExerciseTime,
		&i.Rating,
	)
	return i, err
}

const startTraining = `-- name: StartTraining :one
UPDATE training
SET 
    started_at = COALESCE($1, CURRENT_TIMESTAMP),
    is_done = false
WHERE id = $2 AND user_id = $3
RETURNING id, user_id, is_done, planned_date, actual_date, started_at, finished_at, total_duration, total_rest_time, total_exercise_time, rating
`

type StartTrainingParams struct {
	StartedAt sql.NullTime `json:"started_at"`
	ID        int64        `json:"id"`
	UserID    uuid.UUID    `json:"user_id"`
}

// Начать тренировку (установить время начала)
func (q *Queries) StartTraining(ctx context.Context, arg StartTrainingParams) (Training, error) {
	row := q.db.QueryRowContext(ctx, startTraining, arg.StartedAt, arg.ID, arg.UserID)
	var i Training
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IsDone,
		&i.PlannedDate,
		&i.ActualDate,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TotalDuration,
		&i.TotalRestTime,
		&i.TotalExerciseTime,
		&i.Rating,
	)
	return i, err
}

const updateExerciseTime = `-- name: UpdateExerciseTime :one
UPDATE trained_exercise
SET 
    doing = COALESCE($1, doing),
    rest = COALESCE($2, rest),
    time = COALESCE($3, time)  -- Общее время упражнения (doing + rest)
WHERE id = $4 AND training_id = $5
RETURNING id, training_id, exercise_id, weight, approaches, reps, time, doing, rest, notes
`

type UpdateExerciseTimeParams struct {
	Doing      sql.NullInt64 `json:"doing"`
	Rest       sql.NullInt64 `json:"rest"`
	Time       sql.NullInt64 `json:"time"`
	ID         int64         `json:"id"`
	TrainingID int64         `json:"training_id"`
}

// Обновление времени выполнения упражнения (doing) и времени отдыха (rest)
func (q *Queries) UpdateExerciseTime(ctx context.Context, arg UpdateExerciseTimeParams) (TrainedExercise, error) {
	row := q.db.QueryRowContext(ctx, updateExerciseTime,
		arg.Doing,
		arg.Rest,
		arg.Time,
		arg.ID,
		arg.TrainingID,
	)
	var i TrainedExercise
	err := row.Scan(
		&i.ID,
		&i.TrainingID,
		&i.ExerciseID,
		&i.Weight,
		&i.Approaches,
		&i.Reps,
		&i.Time,
		&i.Doing,
		&i.Rest,
		&i.Notes,
	)
	return i, err
}

const updateTrainedExercise = `-- name: UpdateTrainedExercise :one
UPDATE trained_exercise
SET 
    weight = COALESCE($1, weight),
    approaches = COALESCE($2, approaches),
    reps = COALESCE($3, reps),
    time = COALESCE($4, time),
    doing = COALESCE($5, doing),
    rest = COALESCE($6, rest),
    notes = COALESCE($7, notes)
WHERE id = $8
RETURNING id, training_id, exercise_id, weight, approaches, reps, time, doing, rest, notes
`

type UpdateTrainedExerciseParams struct {
	Weight     sql.NullString `json:"weight"`
	Approaches sql.NullInt32  `json:"approaches"`
	Reps       sql.NullInt32  `json:"reps"`
	Time       sql.NullInt64  `json:"time"`
	Doing      sql.NullInt64  `json:"doing"`
	Rest       sql.NullInt64  `json:"rest"`
	Notes      sql.NullString `json:"notes"`
	ID         int64          `json:"id"`
}

func (q *Queries) UpdateTrainedExercise(ctx context.Context, arg UpdateTrainedExerciseParams) (TrainedExercise, error) {
	row := q.db.QueryRowContext(ctx, updateTrainedExercise,
		arg.Weight,
		arg.Approaches,
		arg.Reps,
		arg.Time,
		arg.Doing,
		arg.Rest,
		arg.Notes,
		arg.ID,
	)
	var i TrainedExercise
	err := row.Scan(
		&i.ID,
		&i.TrainingID,
		&i.ExerciseID,
		&i.Weight,
		&i.Approaches,
		&i.Reps,
		&i.Time,
		&i.Doing,
		&i.Rest,
		&i.Notes,
	)
	return i, err
}

const updateTraining = `-- name: UpdateTraining :one
UPDATE training
SET 
    is_done = COALESCE($1, is_done),
    planned_date = COALESCE($2, planned_date),
    actual_date = COALESCE($3, actual_date),
    started_at = COALESCE($4, started_at),
    finished_at = COALESCE($5, finished_at),
    total_duration = COALESCE($6, total_duration),
    total_rest_time = COALESCE($7, total_rest_time),
    total_exercise_time = COALESCE($8, total_exercise_time),
    rating = COALESCE($9, rating)
WHERE id = $10
RETURNING id, user_id, is_done, planned_date, actual_date, started_at, finished_at, total_duration, total_rest_time, total_exercise_time, rating
`

type UpdateTrainingParams struct {
	IsDone            bool          `json:"is_done"`
	PlannedDate       time.Time     `json:"planned_date"`
	ActualDate        sql.NullTime  `json:"actual_date"`
	StartedAt         sql.NullTime  `json:"started_at"`
	FinishedAt        sql.NullTime  `json:"finished_at"`
	TotalDuration     sql.NullInt64 `json:"total_duration"`
	TotalRestTime     sql.NullInt64 `json:"total_rest_time"`
	TotalExerciseTime sql.NullInt64 `json:"total_exercise_time"`
	Rating            sql.NullInt32 `json:"rating"`
	ID                int64         `json:"id"`
}

func (q *Queries) UpdateTraining(ctx context.Context, arg UpdateTrainingParams) (Training, error) {
	row := q.db.QueryRowContext(ctx, updateTraining,
		arg.IsDone,
		arg.PlannedDate,
		arg.ActualDate,
		arg.StartedAt,
		arg.FinishedAt,
		arg.TotalDuration,
		arg.TotalRestTime,
		arg.TotalExerciseTime,
		arg.Rating,
		arg.ID,
	)
	var i Training
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IsDone,
		&i.PlannedDate,
		&i.ActualDate,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TotalDuration,
		&i.TotalRestTime,
		&i.TotalExerciseTime,
		&i.Rating,
	)
	return i, err
}

const updateTrainingTimers = `-- name: UpdateTrainingTimers :one
UPDATE training
SET 
    started_at = COALESCE($1, started_at),
    finished_at = COALESCE($2, finished_at),
    total_duration = COALESCE($3, total_duration),
    total_rest_time = COALESCE($4, total_rest_time),
    total_exercise_time = COALESCE($5, total_exercise_time)
WHERE id = $6
RETURNING id, user_id, is_done, planned_date, actual_date, started_at, finished_at, total_duration, total_rest_time, total_exercise_time, rating
`

type UpdateTrainingTimersParams struct {
	StartedAt         sql.NullTime  `json:"started_at"`
	FinishedAt        sql.NullTime  `json:"finished_at"`
	TotalDuration     sql.NullInt64 `json:"total_duration"`
	TotalRestTime     sql.NullInt64 `json:"total_rest_time"`
	TotalExerciseTime sql.NullInt64 `json:"total_exercise_time"`
	ID                int64         `json:"id"`
}

// Обновление времени тренировки (старт, финиш, общая продолжительность)
func (q *Queries) UpdateTrainingTimers(ctx context.Context, arg UpdateTrainingTimersParams) (Training, error) {
	row := q.db.QueryRowContext(ctx, updateTrainingTimers,
		arg.StartedAt,
		arg.FinishedAt,
		arg.TotalDuration,
		arg.TotalRestTime,
		arg.TotalExerciseTime,
		arg.ID,
	)
	var i Training
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IsDone,
		&i.PlannedDate,
		&i.ActualDate,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TotalDuration,
		&i.TotalRestTime,
		&i.TotalExerciseTime,
		&i.Rating,
	)
	return i, err
}
